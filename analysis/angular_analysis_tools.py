import numpy as np


# This function uses the data dictionary and the trajectory array to arrange the trajectory data by water molecules
# NOTE: this function does NOT assume that there is only trajectory data for the water molecules, it can handle trajectory data that has more types of atoms
# ASSUMPTIONS:  (1) data was generated by the script in reading_tools.py, and it corresponds to either the initial conditions used to generate the trajectory, or that it has the same information with regards to the identity of atoms
#               (2) trj is a numpy array with shape (M,N,4) where M is the number of frames, N is the number of atoms, and the last dimension corresponds to (atom type, x, y, z), where atom type is an integer.
def arrange_trj_data_by_molecules(data,trj,oxygen_type,hydrogen_type,global2local=None):
    # Create mappings
    atom_2_molecule = {}
    OXYGENS = {}
    H1S = {}
    H2S = {}
    N_water_molecules = 0

    for atom in data["Atoms"]:
        atom_2_molecule[atom] = data["Atoms"][atom]["molecule ID"]
        if data["Atoms"][atom]["atom type"] == oxygen_type:
            N_water_molecules += 1
            OXYGENS[atom_2_molecule[atom]] = atom
        if data["Atoms"][atom]["atom type"] == hydrogen_type:
            if atom_2_molecule[atom] not in H1S:
                H1S[atom_2_molecule[atom]] = atom
            elif atom != H1S[atom_2_molecule[atom]]:
                H2S[atom_2_molecule[atom]] = atom

    # remake OXYGENS, H1S, and H2S to only include the molecules that have at least one atom in the global2local directory
    if not global2local==None:
        new_molecule_ID=0
        old2new_moleculeID_map={}
        newOXYGENS={}
        newH1S={}
        newH2S={}
        for molecule in OXYGENS:
            oxygen = OXYGENS[molecule]
            h1 = H1S[molecule]
            h2 = H2S[molecule]
            if (oxygen in global2local) and (h1 in global2local) and (h2 in global2local):
                new_molecule_ID+=1
                old2new_moleculeID_map[molecule]=new_molecule_ID
                newOXYGENS[new_molecule_ID]=global2local[OXYGENS[molecule]]
                newH1S[new_molecule_ID]=global2local[H1S[molecule]]
                newH2S[new_molecule_ID]=global2local[H2S[molecule]]
        N_water_molecules=new_molecule_ID
        OXYGENS=newOXYGENS
        H1S=newH1S
        H2S=newH2S

    # Get dimensions
    M = trj.shape[0]

    # Initialize arrays
    oxygens = np.zeros((M, N_water_molecules, 3))
    h1s = np.zeros((M, N_water_molecules, 3))
    h2s = np.zeros((M, N_water_molecules, 3))

    # Populate arrays based on molecule indexing
    for mol_id in range(1, N_water_molecules + 1):  # Assuming molecule IDs start at 1
        if mol_id in OXYGENS:
            oxygens[:, mol_id - 1, :] = np.double(trj[:, OXYGENS[mol_id] - 1, 1:])
        if mol_id in H1S:
            h1s[:, mol_id - 1, :] = np.double(trj[:, H1S[mol_id] - 1, 1:])
        if mol_id in H2S:
            h2s[:, mol_id - 1, :] = np.double(trj[:, H2S[mol_id] - 1, 1:])
        
    return oxygens, h1s, h2s

# This function calculates the center of mass (COM) positions and velocities for water molecules
# WARNING: this assumes that there is a function that decomposes the entire trajectory data into just the data of the oxygens and the hydrogens of water.
def COM_trj(positions_oxygens,positions_h1s,positions_h2s,velocities_oxygens,velocities_h1s,velocities_h2s,data,hydrogen_type,oxygen_type):
    hydrogen_mass=data["Masses"][hydrogen_type]
    oxygen_mass=data["Masses"][oxygen_type]

    positions_COM=(positions_oxygens*oxygen_mass+positions_h1s*hydrogen_mass+positions_h2s*hydrogen_mass)/(oxygen_mass+2*hydrogen_mass)
    velocities_COM=(velocities_oxygens*oxygen_mass+velocities_h1s*hydrogen_mass+velocities_h2s*hydrogen_mass)/(oxygen_mass+2*hydrogen_mass)

    return positions_COM, velocities_COM

def compute_local_basis_unit_vectors(data, trj, oxygen_type, hydrogen_type, box_size, global2local=None, mode="debug"):

    # use arrange_trj_data_by_molecules to get the positions of the oxygens and hydrogens
    # refer to the documentation and comments of that function (it's in this same script) for more details
    oxygens, h1s, h2s = arrange_trj_data_by_molecules(data,trj,oxygen_type,hydrogen_type,global2local=global2local)

    # Find the vectors from each hydrogen to its corresponding oxygen, applying minimum image convention (most simulations will have periodic boundary conditions, and if the boundary conditions are not periodic it won't affect the behavior of the code)
    r_h1_rel = h1s - oxygens - np.round((h1s - oxygens) / box_size) * box_size
    r_h2_rel = h2s - oxygens - np.round((h2s - oxygens) / box_size) * box_size

    # find the local basis unit vectors for each water molecule:
    #   (a) is parallel to the dipole vector, going from the oxygen to betwenn both hydrogen
    #   (b) is perpendicular to (a) and in the direction of the normal vector of the molecular plane (uses vector from oxygen to one of the two hydrogens to define the molecular plane)
    #   (c) is perpendicular to both (a) and (b)
    a = r_h1_rel+r_h2_rel
    a = np.divide(a, np.linalg.norm(a,axis=2,keepdims=True), where=np.linalg.norm(a,axis=2,keepdims=True) != 0)  # Avoid division by zero (set to 0 where norm is zero)

    b = np.cross(r_h1_rel,a,axis=2)
    b = np.divide(b, np.linalg.norm(b,axis=2,keepdims=True), where=np.linalg.norm(b,axis=2,keepdims=True) != 0)  # Avoid division by zero (set to 0 where norm is zero)

    c = np.cross(a,b,axis=2)
    c = np.divide(c, np.linalg.norm(c,axis=2,keepdims=True), where=np.linalg.norm(c,axis=2,keepdims=True) != 0)  # Avoid division by zero (set to 0 where norm is zero)

    # include a debug statement to check that the unit vectors are properly normalized and orthogonal
    # CHECKS
    if mode=="debug":
        print("a:")
        print(a[0,0,:])
        print("norm(a):\t***should be within machine precision of 1***")
        print(np.linalg.norm(a[0,0,:]))
        print("b:")
        print(b[0,0,:])
        print("norm(b):")
        print(np.linalg.norm(b[0,0,:]))
        print("c:")
        print(c[0,0,:])
        print("norm(c):\t***should be within machine precision of 1***")
        print(np.linalg.norm(c[0,0,:]))
        print("a dot b:\t***should be within machine precision of 0***")
        print(np.dot(a[0,0,:],b[0,0,:]))
        print("b dot c:\t***should be within machine precision of 0***")
        print(np.dot(b[0,0,:],c[0,0,:]))
        print("c dot a:\t***should be within machine precision of 0***")
        print(np.dot(a[0,0,:],c[0,0,:]))

    return a, b, c, oxygens, h1s, h2s
