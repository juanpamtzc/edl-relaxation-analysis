import numpy as np


# This function uses the data dictionary and the trajectory array to arrange the trajectory data by water molecules
# NOTE: this function does NOT assume that there is only trajectory data for the water molecules, it can handle trajectory data that has more types of atoms
# ASSUMPTIONS:  (1) data was generated by the script in reading_tools.py, and it corresponds to either the initial conditions used to generate the trajectory, or that it has the same information with regards to the identity of atoms
#               (2) trj is a numpy array with shape (M,N,4) where M is the number of frames, N is the number of atoms, and the last dimension corresponds to (atom type, x, y, z), where atom type is an integer.
def arrange_trj_data_by_molecules(data,trj,oxygen_type,hydrogen_type,global2local=None):
    # Create mappings
    atom_2_molecule = {}
    OXYGENS = {}
    H1S = {}
    H2S = {}
    N_water_molecules = 0
    local_molecule_id=0
    molecule_id_map={}

    for atom in data["Atoms"]:
        atom_2_molecule[atom] = data["Atoms"][atom]["molecule ID"]
        if data["Atoms"][atom]["atom type"] == oxygen_type:
            N_water_molecules += 1
            OXYGENS[atom_2_molecule[atom]] = atom
        if data["Atoms"][atom]["atom type"] == hydrogen_type:
            if atom_2_molecule[atom] not in H1S:
                H1S[atom_2_molecule[atom]] = atom
            elif atom != H1S[atom_2_molecule[atom]]:
                H2S[atom_2_molecule[atom]] = atom

    # remake OXYGENS, H1S, and H2S to only include the molecules that have at least one atom in the global2local directory
    if not global2local==None:
        new_molecule_ID=0
        old2new_moleculeID_map={}
        newOXYGENS={}
        newH1S={}
        newH2S={}
        for molecule in OXYGENS:
            oxygen = OXYGENS[molecule]
            h1 = H1S[molecule]
            h2 = H2S[molecule]
            if (oxygen in global2local) and (h1 in global2local) and (h2 in global2local):
                new_molecule_ID+=1
                old2new_moleculeID_map[molecule]=new_molecule_ID
                newOXYGENS[new_molecule_ID]=global2local[OXYGENS[molecule]]
                newH1S[new_molecule_ID]=global2local[H1S[molecule]]
                newH2S[new_molecule_ID]=global2local[H2S[molecule]]
        N_water_molecules=new_molecule_ID
        OXYGENS=newOXYGENS
        H1S=newH1S
        H2S=newH2S

    # Get dimensions
    M = trj.shape[0]

    # Initialize arrays
    oxygens = np.zeros((M, N_water_molecules, 3))
    h1s = np.zeros((M, N_water_molecules, 3))
    h2s = np.zeros((M, N_water_molecules, 3))

    # Populate arrays based on molecule indexing
    for mol_id in range(1, N_water_molecules + 1):  # Assuming molecule IDs start at 1
        if mol_id in OXYGENS:
            oxygens[:, mol_id - 1, :] = np.double(trj[:, OXYGENS[mol_id] - 1, 1:])
        if mol_id in H1S:
            h1s[:, mol_id - 1, :] = np.double(trj[:, H1S[mol_id] - 1, 1:])
        if mol_id in H2S:
            h2s[:, mol_id - 1, :] = np.double(trj[:, H2S[mol_id] - 1, 1:])
        
    return oxygens, h1s, h2s


# This function calculates the center of mass (COM) positions and velocities for water molecules
# WARNING: this assumes that there is a function that decomposes the entire trajectory data into just the data of the oxygens and the hydrogens of water.
def COM_trj(positions_oxygens,positions_h1s,positions_h2s,velocities_oxygens,velocities_h1s,velocities_h2s,data,hydrogen_type,oxygen_type):
    hydrogen_mass=data["Masses"][hydrogen_type]
    oxygen_mass=data["Masses"][oxygen_type]

    positions_COM=(positions_oxygens*oxygen_mass+positions_h1s*hydrogen_mass+positions_h2s*hydrogen_mass)/(oxygen_mass+2*hydrogen_mass)
    velocities_COM=(velocities_oxygens*oxygen_mass+velocities_h1s*hydrogen_mass+velocities_h2s*hydrogen_mass)/(oxygen_mass+2*hydrogen_mass)

    return positions_COM, velocities_COM


